# Webブラウザ

## HTTPリクエスト・レスポンス

ブラウザの最初の仕事はWebサーバーにリクエストを送る為に、URLを解読する。<br>

URLの要素<br>
http:(プロトコル) + // + Webサーバー名 + / + ディレクトリ名 + / + ファイル名<br> 

具体例<br>
http://ww.lab.glasscom.com/dir1/file1.html<br>

HTTPとは... クライアントとサーバーがやり取りするメッセージの内容や手順について定めたもの<br>

### HTTPの簡単な流れ

1. クライアントからサーバーに向けてリクエストのメッセージを送る。

メッセージの中には、「何」を「どうして」ほしいのかが書いてある。<br>

「何」... URI(ファイル名やURLなどのアクセス先)<br>
「どうして」... メソッド(サーバーにどのような動作をしてほしいのかを伝える)<br>
主要なメソッド<br>
GET... URIで指定した情報を取り出す<br>
POST... クライアントからサーバーにデータを送信する。<br>

2. リクエストメッセージがサーバーに届いたら、要求にしたがって動作し、その結果生じるデータをレスポンスメッセージに格納する

先頭部分には、実行結果が正常終了したか、異常が起こったかを表すステータスコードがある。<br>

ステータスコードの例<br>
「404 Not Found」... サーバーにアクセスしたときにファイルが見つからない。

### HTTPのリクエストメッセージを作る

URLの解読し、Webサーバーとファイル名が判明したら、ブラウザはそれを基にHTTPリクエストメッセージを作成する。

HTTPリクエストのフォーマット<br>

1行目<br>

リクエストライン  <メソッド><空白><URI><空白><HTTPバージョン> #リクエストの大まかな内容<br>

2行目~数行から10数行程度<br> 

メッセージ・ヘッダー   #付加的な細かい情報を書き留めておく(日付、クライアントが扱えるデータの種類、言語など)<br>

空白が1行<br>

空白の後<br>
メッセージ・ボディ #メッセージの本体、送信するデータ<br>
メソッドがGETの場合はメソッドとURIのみで何をすべきか判断できるので、メッセージボディに書く送信データは無し。<br>
メソッドがPOSTの場合はフォームに入力したデータをメッセージボディの部分に書く。<br>

画像ファイルがある場合は、文書ファイルのリクエストと画像ファイルのリクエストの両方、送信する。<br>
画像が2枚ある文書ファイルの場合、文書ファイルで1回、画像ファイルで2回の合計3回リクエストメッセージを送信する。

### リクエストを送るとレスポンスが帰ってくる

リクエストを送るとWebサーバーからレスポンスメッセージが返ってくる。<br>
レスポンス・メッセージのフォーマットも基本的な考え方はリクエスト・メッセージと同じだが、1行目のみ違う。<br>
レスポンスメッセージの場合は、正常終了したのかエラーが起きたのかといったリクエストの実行結果をを表すステータスコードとレスポンスフレーズを1行目に書くことになっている。<br>

ステータスコードとレスポンスフレーズは同じ内容を表すが用途が違う。<br>

ステータスコード→数字で書いたもの。主に、プログラムなどに実行結果を知らせる目的を持っている。<br>
レスポンスフレーズ→文章で書いたもの。主に、人間に実行結果を知らせる目的を持っている。<br>

レスポンスメッセージが帰ってきたら、そこからデータを取り出して、画面に表示する。<br>

ステータスコードの概要<br>
| コード | 説明                              |
| ------ | --------------------------------- |
| 1xx    | 処理の経過状況をなどを通知する      |
| 2xx    | 正常終了                          |
| 3xx    | 何らかのアクションが必要であることを表す |
| 4xx    | クライアント側のエラー              |
| 5xx    | サーバー側のエラー                  |


## WebサーバーのIPアドレスをDNSサーバーに問い合わせる

### IPアドレスの基本

HTTPメッセージを作成したら、それをOSに依頼してWebサーバーに送信してもらう。<br>
その際に、ブラウザはURLのサーバードメインからIPアドレスを調べる必要がある。<br>
(OSに送信を依頼するときは、ドメイン名ではなくIPアドレスでメッセージを届ける必要があるため)<br>

ネットワークはサブネットという小さなネットワークを一つの単位と考え、それをルーターで接続することによって全体のネットワークが出来上がっている。<br>
サブネットの例:ハブに何台かのパソコンが接続されたもの<br>

ネットワークに対して、「○○丁目▽▽番地」というような恰好でネットワークの住所ともいえるアドレスを割り当てる。<br>
「○○丁目」に相当する番号をサブネットに割り当てる→ネットワーク番号<br>
「▽▽番地」に相当する番号をコンピュータ(パソコンなど)に割り当てる→ホスト番号<br>

ITアドレスは32ビットのデジタルデータでそれを8ビットずつドットで区切って10進数で表記する<br>
例:10.11.12.13

上記はネットワーク番号とホスト番号の二つを合わせており、この情報のみだとどこからどこまでがネットワーク番号、ホスト番号というのが分からない。<br>
内訳を表す情報を必要に応じてIPアドレスに付加する。→ネットマスク<br>

ネットマスクも32ビットのデジタルデータ。<br>
11111111.11111111.11111111.00000000<br>
1がネットワーク部分、0がホスト部分、下記は上記を10進数に直したもの<br>
255.255.255.0<br>
そして、IPアドレスにネットマスク情報を付加したもの<br>
10.11.12.13/24 →24はネットワーク部分のビット数<br>

ホスト部分が全て0→サブネット自体<br>
ホスト部分が全て1→サブネット上にある機器全員にパケットを送るブロードキャストを表す。

### ドメイン名とIPアドレス

ドメイン名→覚えやすい、分かりやすいがデータ量が増えてしまい、データを運ぶのに余分な時間がかかる<br>
IPアドレス→覚えにくい、分かりにくいがデータ量は32ビットしかない。<br>

→人間はドメイン名、コンピュータはIPアドレス
→双方を変換する仕組みがDNS

### DNS

ブラウザは、DNSサーバーにドメイン名で問合せをし、IPアドレスが返ってくる(名前解決やネーム・リゾリューションと呼ぶ)

DNSサーバーへの問い合わせ方<br>

(DNS)リゾルバ→DNSサーバーに対してクライアントとして動作するもの

リゾルバの実態はSocketライブラリに入っている部品化したプログラム(プログラム名→gethostbyname)<br>

Socketライブラリ→OSに組み込まれているネットワーク機能をアプリから呼びだす為のプログラムの部品を集めたもの。<br>

リゾルバの使い方
1. リゾルバの使い方はリゾルバのプログラム名とドメイン名を書く<br>
2. リゾルバがDNSサーバーが問合せのメッセージを送る
3. DNSサーバーから応答メッセージが返ってくる
4. 応答メッセージの中にIPアドレスが格納されており、リゾルバはそれを取り出してブラウザから指定されたメモリー領域の中に書き込む
5. ブラウザがメモリー領域の中からIPアドレスを取り出して、HTTPリクエストメッセージと一緒にOSに渡して送信を依頼する

```
<!-- ソースコードの例 -->
<!-- 下記の1行を実行すると、メモリー領域にサーバーのIPアドレスが書き込まれる -->
<メモリー領域> = gethostbyname('www.lab.glasscom.com');
```

### リゾルバ内部の動き

1. ブラウザがリゾルバを呼びだし、制御がリゾルバに移る
2. リゾルバがDNSに問い合わせる為のメッセージを作成し、OS内部に組み込まれたプロトコル・スタックを呼び出す(リゾルバもブラウザと同じようにネットワークに対してデータを送受信する機能を持っていない為)
3. プロトコル・スタックがメッセージを送る動作を実行し、LANアダプタを通じてメッセージがDNSサーバーに向けて送信される※
4. DNSサーバーにメッセージが届いたら、内容を知らべ、応答メッセージに書き込んでクライアントに送り返す
5. ネットワークを通って、クライアント側に届き、プロトコル・スタックを経由してリゾルバに渡される
6. リゾルバが中身を確認して、そこからIPアドレスを取り出し、メモリー領域に格納し、ブラウザに渡される(リゾルバの動作は終了)
7. ブラウザはメモリー領域に格納されたIPアドレスを必要な時に取り出すことができる

※DNSサーバーにメッセージ送信する時もDNSサーバーのIPアドレスが必要だが、これはTCP/IPの設定項目として、コンピュータにあらかじめ設定されている(設定方法はOSの種類によって異なる)

## 世界中のDNSサーバーが連携する

### DNSサーバーの基本動作

DNSに問い合わせるメッセージには3つの情報が含まれている

* 名前
サーバーやメール配送先の(メールアドレスの@以後の名前)
* クラス
ネットワークの種類を表す。現在はクラスはインターネットを表す「IN」という値になる
* タイプ
名前にどのようなタイプの情報が対応づけられているのかを表す。<br>
「A」→IPアドレスが対応している<br>
「MX」→メール配送先が対応している<br>

そして、DNSサーバーには3つの情報とそれに対応するクライアントに返答する項目が設定されている。(IPアドレスやメールの配送先など)

DNSサーバーに登録されている除法は設定ファイルなどに書き込まれている。<br>
一組の情報(名前、クラス、タイプ、クライアントに返答する項目)のことをリソースレコードという。

### ドメインの階層

インターネット上には莫大な数のサーバやパソコンがあるので、全部を1台のDNSサーバーに登録することはできない。<br>
→情報を分散させて多数のDNSサーバーに登録し、その多数のDNSサーバーが連携して情報がどこにあるのかを探し出す。

DNSサーバーに登録する情報には全て ドメイン名 という階層的な構造を持つ名前が付けられている。<br>

DNSで扱う名前は「 www.lab.glasscom.com 」というようにドットで区切られており、ドットが階層の区切りを表す。<br>
そして、右に位置するものが上位の階層を表す。そして、ドットで区切られた一つのものを ドメイン と呼ぶ。<br>

DNSサーバーには ドメイン が登録されている。するとドメインの階層構造と同じ恰好でDNSサーバ-が登録されることになる。

インターネットのドメインは下位にドメインを作って国や会社や団体を割り当てたもの。<br>

「www.nikkeibp.co.jp」

jp→日本に割り当てたドメイン<br>
co→日本国内のドメインを分類するために設定されたドメインで会社を表す<br>
nikkeibp→会社を表す<br>
www→サーバーの名前

### 担当のDNSサーバーを探し、IPアドレスを取得

DNSサーバーは下位のドメインを担当するDNSサーバーのIPアドレスがその上位のDNSサーバーに登録されている。<br>
例:lab.glasscom.comというドメインを担当するDNSサーバーのIPアドレスをglasscom.comドメインのDNSサーバーに登録し、glasscom.comのDNSサーバーのIPアドレスをcomドメインのDNSサーバーに登録する。<br>
→上位のDNSサーバーに行けば、下位のDNSサーバーのIPアドレスをが分かり、そこに問合せメッセージを送ることができる。<br>
comやjpといったドメインをトップレベル・ドメインと呼び、さらに上位にルート・ドメインと呼ぶドメインがある<br>
(ルートドメインにはcomやjpといったドメイン名が無いので、普通にドメイン名を書く時は省略されるが、明示的に書く場合は「com.」のように最後にピリオドを付け、このピリオドでルートドメインを表す。)<br>
そして、ルートドメインのDNSサーバーをインターネット上のDNSサーバー全部に登録することで、どのDNSサーバーからでも目的のDNSサーバーにたどり付ける。<br>
ルートドメインの数は全世界で13個しかない。

### DNSサーバーのキャッシュ機能

DNSサーバーは一度調べたドメイン名をキャッシュに記録しておく機能があり、問い合わせたドメイン名に該当する情報がキャッシュにあれば、その情報をすばやく回答することができる。<br>
また、問い合わせたドメイン名が存在しない場合は、「存在しない」という回答が返ってくるが、そちらもキャッシュに登録されていれば、すばやく回答することができる。<br>
このキャッシュの仕組みには、注意点が1つあり、キャッシュに保存した後、登録情報が変更される場合があるのでキャッシュにある情報は正しいとは限らない。<br>
そのため、DNSサーバーのキャッシュには有効期限が設定されており、有効期限を過ぎたらそのデータはキャッシュから削除される。<br>
さらに、問合せに回答する時にその情報がキャッシュに保存されたものか、登録元のDNSサーバーからの返答なのか、キャッシュからの返答なのかを知らせることになっている。

## プロトコル・スタックにメッセージ送信を依頼する

### データ送受信動作の概要

IPアドレスを調べたら、アクセス先のWebサーバーにメッセージ(デジタルデータ)を送信するようOS内部にあるプロトコル・スタックに依頼する。<br>
プロトコル・スタックにメッセージ送信動作を依頼する時は、Socketライブラリのプログラム部品を決められた順番で呼びだす。<br>

Socketライブラリを用いたデータ送受信は、コンピュータの間にパイプのようなものを繋ぎ、そこを通ってデータが流れ、相手側に届く。<br>
パイプの両端にはデータの出入口のソケットと呼ばれるものがあり、まずはそのソケットを作成し、それを繋げる。<br>
実際の流れは、まずサーバー側でソケットを作成し、次にクライアント側もソケットを作成し、そのソケットからパイプを伸ばしてサーバー側のソケットに繋ぐ。<br>
ソケットが繋がれば、データを放り込むというイメージでデータ送受信動作を実行する。<br>
データの送受信動作が終われば、繋がっていたパイプを外す。(外す時はアプリケーション側で外す順番を決めておく)<br>
パイプを外したら、ソケットを抹消し、通信動作は終了。<br>
要約すると、4つのフェーズになる

1. ソケット作成フェーズ
2. パイプを繋ぐフェーズ
3. データを送受信するフェーズ
4. パイプを外して、ソケットを抹消するフェーズ

このフェーズに従って、Socketライブラリ中のプログラム部品を順番に呼びだしてデータ送受信動作を実行する。<br>
(実際に4つの動作を実行するのは、OS内部のプロトコルスタック)

### ソケット作成するフェーズのアプリケーション(ブラウザ)の依頼動作

ブラウザがSocketライブラリの「socket」というプログラム部品を呼びだして、ソケットを作成する<br>
ソケットが作成できたら ディスクリプタ というものが返ってくるのでそれを受け取って、メモリーに記録しておく。<br>

ディスクリプタ→ソケットを識別するために使うもので、ソケットに割り当てた番号のようなもの。
(ブラウザでウィンドウを2つ開いて、2つのWebサーバーに同時にアクセスする時は、ソケットも2つ作成しなければならない。このように1つのコンピュータにソケットが複数存在することもあるので、それらを識別しなければならない)

### パイプを繋ぐフェーズのアプリケーション(ブラウザ)の依頼動作

ブラウザがSocketライブラリの「connect」というプログラム部品を呼びだして、パイプを繋ぐ依頼をする<br>

「connect」を呼びだす際に「ディスクリプタ」「IPアドレス」「ポート番号」の3つの値を指定する。<br>

ディスクリプタ... ソケットを作成した際に返ってきたディスクリプタで、「connect」がプロトコル・スタックに通知する<br>
                  そして、プロトコル・スタックが通知されたディスクリプタを見て、どのソケットをサーバー側のソケットに接続するのかを判断し、接続動作を実行する<br>

IPアドレス... DNSサーバーに問い合わせて調べた、IPアドレス(データ送信(メッセージを送る)の際はプロトコル・スタックにIPアドレスを知らせる必要がある)

ポート番号... 接続相手側のソケットを識別するもので、サーバー側のポート番号はアプリケーションの種類によって予め決められている値を使う。<br>
              (Webだったら80番、メールだった25番など)<br>
              クライアント側のポート番号は、ソケットを作成する際にプロトコル・スタックが適当な値を割り当てる。<br>
              そして、摂動動作を実行する時に、サーバー側に通知される<br>

接続相手と繋がったら、プロトコル・スタックは接続相手のIPアドレスやポート番号をソケットに記録し、データの送受信が可能になる

### データを送受信するフェーズのアプリケーション(ブラウザ)の依頼動作

送信動作<br>

ブラウザがSocketライブラリの「write」というプログラム部品を呼びだして、データを送信する、依頼をする<br>

具体的には、ブラウザは送信データ(HTTPリクエスト・メッセージ)をメモリーに用意しておく。<br>
「write」を呼びだし、ディスクリプタと送信データを指定する<br>
プロトコル・スタックが送信データをサーバーに向けて、送信する<br>

受信動作<br>

ブラウザがSocketライブラリの「read」というプログラム部品を呼びだして、データを受信する、依頼をする<br>

具体的には、「read」を呼びだして、レスポンスメッセージを格納するためのメモリー領域を指定する(そのメモリー領域のことを受信バッファと呼ぶ)<br>
レスポンスメッセージが返ってきたときに「read」が受け取って、受信バッファに格納する<br>

受信バッファはブラウザの内部に用意したメモリー領域のため、受信バッファにメッセージを格納した時点でメッセージをブラウザに渡したことになる。

### パイプを外して、ソケットを抹消するフェースのアプリケーション(ブラウザ)の依頼動作

ブラウザがデータを受信し終わったら、送受信動作は終わりなので、Socketライブラリの「close」というプログラム部品を呼びだして、パイプを切断するように依頼をする<br>
→ソケットを繋いでいたパイプのようなものが外れ、ソケットも抹消される<br>

具体的には、Webサーバーがレスポンスメッセージを送り終わったら、Webサーバー側から「close」を呼びだして切断を行う。<br>
すると、それがクライアント側に伝わり、クライアント側のソケットは切断フェーズに入る。<br>
→ブラウザが「read」で受信動作を依頼した時に、「read」は受信データを渡し、送受信動作が終わって切断されたことをブラウザに通知する<br>
そして、ブラウザでも「close」を呼び出して切断フェーズに入る




