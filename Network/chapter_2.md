# TCP/IP、プロトコルスタックが依頼を受けた際の実際の動き

* プロトコル・スタック... OSに組み込まれたネットワーク制御用ソフトウェア<br>

ブラウザから依頼を受けたプロトコル・スタックが TCPプロトコル を用いてメッセージを送受信する4つのフェーズ

1. ソケットを作成する
2. サーバーに接続する
3. データを送受信する
4. サーバーから切断してソケットを抹消

* LANアダプタ... ネットワーク用のハードウェア

## ソケットを作成する

### プロトコル・スタックの内部構成

データ送受信の依頼のおおまかな階層構造<br>

ネットワーク・アプリケーション(ブラウザ、Webサーバー、メーラー、メールサーバー)... ここから下に向けてデータの送受信などの仕事を依頼する<br>

↓<br>

Socketライブラリ(リゾルバ)... DNSサーバーに問い合わせる動作を実行<br> 

↓<br>

プロトコル・スタック(OS内部)<br>

プロトコル・スタックの上部には、「TCP」というプロトコルを使ってデータを送受信する部分と、「UDP」というプロトコルを使ってデータを送受信する部分があり、この2つがアプリケーションからの依頼を受けて送受信動作を実行する<br>

TCP... ブラウザやメールなどの通常のアプリケーションが送受信する場合に使う<br>
UDP... DNSサーバーへの問い合わせなどで短い制御用のデータを送受信する場合に使う<br>

その下に「IP」というプロトコルを使ってパケット送受信動作をコントロールをする部分がある。<br>

IP... インターネットでデータを運ぶ時は、データを小分けにして パケット という形で運ぶが、そのパケットを通信相手まで運ぶのがIPの主な役割で、IPの中には「ICMP」とか「ARP」というプロトコルを扱う部分がある。<br>

ICMP... パケットを運ぶ時に発生するエラーを通知したり、制御用のメッセージを通知する時に使う<br>
ARP(アープ)... IPアドレスに対応するイーセネットのMACアドレスを調べる時に使う

↓<br>

LANドライバ... LANアダプタのハードウェアをコントロールするもので、下にあるLANアダプタが実際の送受動作、つまりケーブルに対して信号を送受信する動作を実行する<br>

↓<br>

LANアダプタ

### ソケットの実態

ソケットの実態は通信制御用の制御情報または、制御情報を記録したメモリー領域<br>
→プロトコル・スタックは内部に制御情報を記録するメモリー領域を持ち、そこに通信動作を制御するための制御情報を記録する<br>
例:通信相手のIPアドレス、ポート番号、通信動作がどのような進行状態か<br>

プロトコルスタックはこの制御情報(ソケット)を参照しながら、動作する<br>

例:データ送信時に相手側のIPアドレスやポート番号を見て、データを送信する<br>
   データ送信をした後の、返事があるのかや送信動作後の経過時間を見て、送り直しを動作が必要か判断する<br>

### socketを呼び出した時の動き

<TCP担当部分>

ブラウザが「socket」を呼び出してソケットを作るように依頼してきたら、プロトコル・スタックは依頼に従いソケットを1つ作成する。<br>

作成の流れ<br>

1. プロトコル・スタックが最初に行うことは、ソケット1つ分のメモリー領域を確保し、そこに中身に相当する制御情報を記録する<br>
   (この時点では、ソケットは作成直後で、まだ送受信動作が始まっていない初期状態のため、初期状態であることを表す制御情報をメモリーに記録する)<br>
   →これで、ソケットが出来上がったことになる。

2. プロトコル・スタックはそのソケットを示すディスクリプタをブラウザに知らせる。
   →以後ブラウザはプロトコル・スタックにデータの送受信動作を依頼する時に、ディスクリプタを通知する<br>
   (ディスクリプタが分かれば、どのソケットかが分かるので、プロトコル・スタックはそのソケットを見て通信相手の必要な情報が分かる)

## サーバーに接続する

### 接続するとは

ソケットを作成したら、ブラウザは「connect」を呼びだして、自分のソケットをサーバー側に接続する<br>

接続するとは...通信相手との間で制御情報をやり取りして、ソケットに必要な情報を記録し、データを送受信可能な状態にする<br>

制御情報... IPアドレスやポート番号などのデータ送受信動作をコントロールするための情報<br>

接続動作の役割<br>

* 通信相手(サーバー)の情報をプロトコル・スタックに知らせる

クライアント側がソケットを作成した直後はまだ何も記録されていないので、通信相手もわからず、送信依頼が来てもどこにデータを送ったらいいのか分からない。<br>
ブラウザはIPアドレスを知っているし、ポート番号はルールで決まっているので(HTTP 80番)、その情報をプロトコル・スタックに知らせる

* クライアント側からサーバー側に通信相手に通信動作の開始を伝える
サーバー側もソケットを作成するだけでは通信相手はわからず、サーバー側のアプリも通信相手がわからない。<br>
→クライアント側からIPアドレスやポート番号などの情報を知らせて、通信したいということをサーバー側に伝えることで、サーバー側のプロトコル・スタックもクライアントの情報を持つことができる。

* バッファメモリーの確保
データの送受信動作を実行する時は、送受信するデータを一時的に格納するメモリー領域が必要。<br>
このメモリー領域をバッファ・メモリーと呼び、その確保も接続動作の時に実行する。

### 先頭部分に制御情報を記載したヘッダーを配置する

制御情報には大きく下記の2種類ある<br>

1. クライアントとサーバーが互いに連絡を取り合うためにやり取りする制御情報(ヘッダーに書き込まれる情報)

接続動作、データの送受信の動作、切断動作などの通信動作全体でどんな情報が必要なのか検討され、その内容、項目がTCPプロトコルの仕様で規定されている。<br>

例:送信元ポート番号、宛先ポート番号、シーケンス番号(送信データの連番)、ACK番号(受信データの連番)<br>

この項目は固定化されており、接続、送受信、切断の格フェーズでクライアントとサーバーがやり取りする都度、この制御情報を付加する<br>
具体的には、クライアントとサーバーがやり取りするパケットの先頭部分に付加するということ。<br>

<パケット全体><br>
[制御情報][データ]<br>

接続動作の段階では、まだデータの送受信は行わないので、パケットの中身は制御情報のみになる。

<パケット全体><br>
[制御情報]<br>

この制御情報のことをパケットの先頭部分に配置することから、「ヘッダー」と呼ぶ。<br>
同じような制御情報はイーサネットやIPにもあり、それも「ヘッダー」と呼ぶので色々なヘッダーが説明で出てくる場合は「TCPヘッダー」「イーサネット・ヘッダー」「IPヘッダー」というように何のヘッダーか分かるようにする。<br>

クライアントとサーバーはこのヘッダーに必要な情報を記載して連絡を取り合いながら通信動作を進めていく。

2. ソケットに記録してプロトコルスタックの動作をコントロールするための制御情報(ソケット(プロトコル・スタックのメモリー領域)に記録される情報)

ソケットにアプリケーション(ブラウザ)から通知された情報、通信相手から受け取った情報、送受信動作の進行状況などが随時記録されていく。<br>
そしてプロトコル・スタックは逐一その情報を参照しながら動く。→ソケットの制御情報はプロトコル・スタックのプログラムと一体化している。<br>

プロトコル・スタックがどのような情報を必要とするかは、プロトコル・スタックの作り方(OS)によって違うが、この情報は通信相手からは見えないし、ルールに従いヘッダーに必要な情報を記載してやり取りすれば、問題なく通信できる。

### 接続動作の実際の動き

ブラウザがSocketライブラリの「connect」を呼び出す。

```
connect(<ディスクリプタ>, <サーバー側のIPアドレスとポート番号>,...)
```
上記のようにサーバー側のIPアドレスとポート番号を書くことによって、それがプロトコル・スタックのTCP担当部分に伝わるので、IPアドレスで示された相手(サーバーのTCP担当部分)との間で制御情報をやり取りする。<br>

やりとりのステップ<br>

1. データ送受信動作の開始を表す制御情報を記載したヘッダーを作成する

ポイント<br>
送信元と宛先のポート番号。これで送信元となるクライアント側のソケットとサーバー側のソケットを特定できる。<br>

コントロール・ビットのSYN。ビットを1にすることで接続するという意味になる。

2. 作成したTCPヘッダーを、IP担当部分に渡して送信するように依頼する。

3. IP担当部分がパケット送信動作を実行し、ネットワークの中を通ってパケットがサーバーのIP担当部分に届く。

4. サーバー側のIP担当部分がそれを受け取り、TCP担当部分に渡す。

5. サーバー側のTCP担当部分がTCPヘッダーを調べて、そこに記載されている宛先ポート番号に該当するソケットを探す。

TCPヘッダーの宛先ポート番号と同じ番号が記録されたものが該当するソケットになる。

6. 該当するソケットが見つかったらそこに必要な情報を記録して、接続動作が進行中という状態にする。

7. サーバーのTCP担当部分TCPヘッダーを作成する

クライアントと同じように送信元や宛先のポート番号、SYNビットなどをセットしたTCPヘッダーを作成する。<br>

コントロール・ビットのACKも1にする。パケットを受け取ったことを知らせる為。<br>
→ネットワークはエラーがつきもので、パケットが消えることもあるため、パケットが届いた事を確認し合いながら動作を進める。<br>
その確認の為に、ACKビットを1にする。

8. 作成したTCPヘッダーをIP担当部分に渡して、クライアントに送り返すよう依頼する。

9. パケットがクライアントに返り、IP担当部分を経由して、TCP担当部分に届く。

10. TCPヘッダーを調べて、サーバー側の接続動作が成功したかどうか確認する。

SYNが1なら接続成功なので、ソケットにIPアドレスやポート番号などを記録する。<br>
また、ソケットに「接続完了」を表す制御情報を記録する。

11. ACKビットを1にしたTCPヘッダーを送り返し、それがサーバーに届いたら接続動作のやり取りは終了。

サーバーと同じように(7)、パケットが届いたことをサーバーに知らせるため。

上記の流れでソケットはデータを送受信できる状態になる。<br>
(このとき、パイプのようなものでソケットがつながっていると考える。)<br>

このパイプのようなものを「コネクション」と呼び、データを送受信している間(closeと呼びだして切断するまでの間)ずっと存在している。<br>

コネクションが作成できたら、プロトコル・スタックの接続動作は終わりなので、アプリケーション(ブラウザ)に制御を戻す。

## データを送受信する

## プロトコル・スタックにHTTPリクエスト・メッセージを渡す

アプリ(ブラウザ)が「write」を呼びだして送信データ(HTTPリクエストメッセージ)をプロトコル・スタックに渡し、プロトコル・スタックが送信動作を実行する。<br>

動作のポイント<br>

* プロトコル・スタックは受け取った送信データの中身に何が書いてあるのかは関知せず、送信データの長さの分※だけバイナリ・データが1バイトずつ順番に並んでいると認識するだけ。<br>
※writeを呼びだす時に送信データの長さを指定している

* プロトコル・スタックは受け取ったデータを、すぐに送信するのではなく、とりあえず自分の内部にある送信用バッファ・メモリーにためてアプリが次のデータを渡してくるのを待つ

理由は、送信依頼する時にアプリからプロトコル・スタックに渡すデータの長さはアプリの種類や作り方によって決まり、データを全部一度に送信依頼する場合もあれば、1バイトずつ、あるいは一行分ずつ、細切れにして送信依頼することもある。<br>
何にしてもデータの長さはアプリの事情によって決まりプロトコル・スタックからコントロールすることはできない。<br>
その為、受け取ったデータをすぐに送るという単純な方法だと小さなパケットをたくさん送ってしまう可能性があり、ネットワークの利用効率が低下するのである程度データをためてから送信動作を行う。<br>

どの程度データをためてから送信動作を行うかはOSの種類やバージョンによって異なるが、下記の要素を基に判断する<br>

1. 1つのパケットに格納できるデータのサイズ
プロトコル・スタックは「MTU」というパラメータを基に判断する

MTU... 1つのパケットで運ぶことのできるデジタル・データの最大長のことで、イーサネットでは通常、1500バイトになる。<br>
       この「MTU」にはパケットの先頭部分にヘッダーが含まれているので、そこからヘッダーを除いたものが1つのパケットで運べるTCPデータの最大長になる。<br>
       その最大長の部分を「MSS」と呼び、アプリから受け取ったデータが「MSS」を超えるか、あるいは「MSS」に近い長さに達するまでデータをためておいて送信動作を行えばパケットが細切れになることはない。

2. タイミング
アプリの送信ペースが遅い場合は、MSSに近づくまでデータをためると、そこで時間がかかり送信動作が後れてしまう。<br>
なので、バッファにデータがたまらなくても適当な時間で送信動作を行うべき。<br>
そのため、プロトコル・スタックは内部にタイマーを持ち、それで一定時間以上経過したらパケットを送信するようにする。


この2つの判断要素の兼ね合いを適当に見計らって送信動作を実行する。<br>
(データのサイズを重視すれば送信に時間がかかり、タイミングを重視するとネットワークの利用効率が低下するため)<br>

しかし、TCPプロトコルの仕様にはその兼ね合いに関するルールはなく、実際にどう判断するかはプロトコル・スタックを作る開発者に任されている。<br>
そのため、OSの種類やバージョンによってその辺の動作は異なる。<br>

このように、プロトコル・スタックに一任する方法だと不都合が起こることもあるので、アプリ側で送信タイミングをコントロールする余地も残されている。<br>
データを送信する時にオプションを指定することができ、「バッファにためずにすぐに送信する」を指定すれば、プロトコル・スタックはバッファにためずにすぐに送信動作を実行することができる。(ブラウザとサーバーのやり取りなどにはこのオプションを使うことが多い)

### データが大きい時は分割して送る

HTTPリクエスト・メッセージは普通、それほど長くないので、1つのパケットに収まるが、フォームを使って長いデータを送る場合(ブログや掲示板などの長い文章)は1つのパケットに収まらないほど長くなることもある。(MSSの長さを超える)<br>
その場合は、送信バッファに入っているデータを先頭から順にMSSのサイズに合わせて分割し、分割した断片を1つずつパケットに入れて送信する。<br>
このように送信バッファにたまったデータの断片を送信すべき状況になったら、その先頭部分にTCPヘッダーを付加する。<br>
そこにソケットに記録されている制御情報を基にして、送信ポート番号や宛先ポート番号などの必要な項目を記載して、IP担当部分に渡して送信動作を実行してもらう。

### パケットが届いたことをACK番号を使って確認




