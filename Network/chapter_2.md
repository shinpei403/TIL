# TCP/IP、プロトコルスタックが依頼を受けた際の実際の動き

* プロトコル・スタック... OSに組み込まれたネットワーク制御用ソフトウェア<br>

ブラウザから依頼を受けたプロトコル・スタックが TCPプロトコル を用いてメッセージを送受信する4つのフェーズ

1. ソケットを作成する
2. サーバーに接続する
3. データを送受信する
4. サーバーから切断してソケットを抹消

* LANアダプタ... ネットワーク用のハードウェア

## ソケットを作成する

### プロトコル・スタックの内部構成

データ送受信の依頼のおおまかな階層構造<br>

ネットワーク・アプリケーション(ブラウザ、Webサーバー、メーラー、メールサーバー)... ここから下に向けてデータの送受信などの仕事を依頼する<br>

↓<br>

Socketライブラリ(リゾルバ)... DNSサーバーに問い合わせる動作を実行<br> 

↓<br>

プロトコル・スタック(OS内部)<br>

プロトコル・スタックの上部には、「TCP」というプロトコルを使ってデータを送受信する部分と、「UDP」というプロトコルを使ってデータを送受信する部分があり、この2つがアプリケーションからの依頼を受けて送受信動作を実行する<br>

TCP... ブラウザやメールなどの通常のアプリケーションが送受信する場合に使う<br>
UDP... DNSサーバーへの問い合わせなどで短い制御用のデータを送受信する場合に使う<br>

その下に「IP」というプロトコルを使ってパケット送受信動作をコントロールをする部分がある。<br>

IP... インターネットでデータを運ぶ時は、データを小分けにして パケット という形で運ぶが、そのパケットを通信相手まで運ぶのがIPの主な役割で、IPの中には「ICMP」とか「ARP」というプロトコルを扱う部分がある。<br>

ICMP... パケットを運ぶ時に発生するエラーを通知したり、制御用のメッセージを通知する時に使う<br>
ARP(アープ)... IPアドレスに対応するイーセネットのMACアドレスを調べる時に使う

↓<br>

LANドライバ... LANアダプタのハードウェアをコントロールするもので、下にあるLANアダプタが実際の送受動作、つまりケーブルに対して信号を送受信する動作を実行する<br>

↓<br>

LANアダプタ

### ソケットの実態

ソケットの実態は通信制御用の制御情報または、制御情報を記録したメモリー領域<br>
→プロトコル・スタックは内部に制御情報を記録するメモリー領域を持ち、そこに通信動作を制御するための制御情報を記録する<br>
例:通信相手のIPアドレス、ポート番号、通信動作がどのような進行状態か<br>

プロトコルスタックはこの制御情報(ソケット)を参照しながら、動作する<br>

例:データ送信時に相手側のIPアドレスやポート番号を見て、データを送信する<br>
   データ送信をした後の、返事があるのかや送信動作後の経過時間を見て、送り直しを動作が必要か判断する<br>

### socketを呼び出した時の動き

<TCP担当部分>

ブラウザが「socket」を呼び出してソケットを作るように依頼してきたら、プロトコル・スタックは依頼に従いソケットを1つ作成する。<br>

作成の流れ<br>

1. プロトコル・スタックが最初に行うことは、ソケット1つ分のメモリー領域を確保し、そこに中身に相当する制御情報を記録する<br>
   (この時点では、ソケットは作成直後で、まだ送受信動作が始まっていない初期状態のため、初期状態であることを表す制御情報をメモリーに記録する)<br>
   →これで、ソケットが出来上がったことになる。

2. プロトコル・スタックはそのソケットを示すディスクリプタをブラウザに知らせる。
   →以後ブラウザはプロトコル・スタックにデータの送受信動作を依頼する時に、ディスクリプタを通知する<br>
   (ディスクリプタが分かれば、どのソケットかが分かるので、プロトコル・スタックはそのソケットを見て通信相手の必要な情報が分かる)

## サーバーに接続する

### 接続するとは

ソケットを作成したら、ブラウザは「connect」を呼びだして、自分のソケットをサーバー側に接続する<br>

接続するとは...通信相手との間で制御情報をやり取りして、ソケットに必要な情報を記録し、データを送受信可能な状態にする<br>

制御情報... IPアドレスやポート番号などのデータ送受信動作をコントロールするための情報<br>

接続動作の役割<br>

* 通信相手(サーバー)の情報をプロトコル・スタックに知らせる

クライアント側がソケットを作成した直後はまだ何も記録されていないので、通信相手もわからず、送信依頼が来てもどこにデータを送ったらいいのか分からない。<br>
ブラウザはIPアドレスを知っているし、ポート番号はルールで決まっているので(HTTP 80番)、その情報をプロトコル・スタックに知らせる

* クライアント側からサーバー側に通信相手に通信動作の開始を伝える
サーバー側もソケットを作成するだけでは通信相手はわからず、サーバー側のアプリも通信相手がわからない。<br>
→クライアント側からIPアドレスやポート番号などの情報を知らせて、通信したいということをサーバー側に伝えることで、サーバー側のプロトコル・スタックもクライアントの情報を持つことができる。

* バッファメモリーの確保
データの送受信動作を実行する時は、送受信するデータを一時的に格納するメモリー領域が必要。<br>
このメモリー領域をバッファ・メモリーと呼び、その確保も接続動作の時に実行する。

### 先頭部分に制御情報を記載したヘッダーを配置する

制御情報には大きく下記の2種類ある<br>

1. クライアントとサーバーが互いに連絡を取り合うためにやり取りする制御情報(ヘッダーに書き込まれる情報)

接続動作、データの送受信の動作、切断動作などの通信動作全体でどんな情報が必要なのか検討され、その内容、項目がTCPプロトコルの仕様で規定されている。<br>

例:送信元ポート番号、宛先ポート番号、シーケンス番号(送信データの連番)、ACK番号(受信データの連番)<br>

この項目は固定化されており、接続、送受信、切断の格フェーズでクライアントとサーバーがやり取りする都度、この制御情報を付加する<br>
具体的には、クライアントとサーバーがやり取りするパケットの先頭部分に付加するということ。<br>

<パケット全体><br>
[制御情報][データ]<br>

接続動作の段階では、まだデータの送受信は行わないので、パケットの中身は制御情報のみになる。

<パケット全体><br>
[制御情報]<br>

この制御情報のことをパケットの先頭部分に配置することから、「ヘッダー」と呼ぶ。<br>
同じような制御情報はイーサネットやIPにもあり、それも「ヘッダー」と呼ぶので色々なヘッダーが説明で出てくる場合は「TCPヘッダー」「イーサネット・ヘッダー」「IPヘッダー」というように何のヘッダーか分かるようにする。<br>

クライアントとサーバーはこのヘッダーに必要な情報を記載して連絡を取り合いながら通信動作を進めていく。

2. ソケットに記録してプロトコルスタックの動作をコントロールするための制御情報(ソケット(プロトコル・スタックのメモリー領域)に記録される情報)

ソケットにアプリケーション(ブラウザ)から通知された情報、通信相手から受け取った情報、送受信動作の進行状況などが随時記録されていく。<br>
そしてプロトコル・スタックは逐一その情報を参照しながら動く。→ソケットの制御情報はプロトコル・スタックのプログラムと一体化している。<br>

プロトコル・スタックがどのような情報を必要とするかは、プロトコル・スタックの作り方(OS)によって違うが、この情報は通信相手からは見えないし、ルールに従いヘッダーに必要な情報を記載してやり取りすれば、問題なく通信できる。

### 接続動作の実際の動き

ブラウザがSocketライブラリの「connect」を呼び出す。

```
connect(<ディスクリプタ>, <サーバー側のIPアドレスとポート番号>,...)
```
上記のようにサーバー側のIPアドレスとポート番号を書くことによって、それがプロトコル・スタックのTCP担当部分に伝わるので、IPアドレスで示された相手(サーバーのTCP担当部分)との間で制御情報をやり取りする。<br>

やりとりのステップ<br>

1. データ送受信動作の開始を表す制御情報を記載したヘッダーを作成する

ポイント<br>
送信元と宛先のポート番号。これで送信元となるクライアント側のソケットとサーバー側のソケットを特定できる。<br>

コントロール・ビットのSYN。ビットを1にすることで接続するという意味になる。

2. 作成したTCPヘッダーを、IP担当部分に渡して送信するように依頼する。

3. IP担当部分がパケット送信動作を実行し、ネットワークの中を通ってパケットがサーバーのIP担当部分に届く。

4. サーバー側のIP担当部分がそれを受け取り、TCP担当部分に渡す。

5. サーバー側のTCP担当部分がTCPヘッダーを調べて、そこに記載されている宛先ポート番号に該当するソケットを探す。

TCPヘッダーの宛先ポート番号と同じ番号が記録されたものが該当するソケットになる。

6. 該当するソケットが見つかったらそこに必要な情報を記録して、接続動作が進行中という状態にする。

7. サーバーのTCP担当部分TCPヘッダーを作成する

クライアントと同じように送信元や宛先のポート番号、SYNビットなどをセットしたTCPヘッダーを作成する。<br>

コントロール・ビットのACKも1にする。パケットを受け取ったことを知らせる為。<br>
→ネットワークはエラーがつきもので、パケットが消えることもあるため、パケットが届いた事を確認し合いながら動作を進める。<br>
その確認の為に、ACKビットを1にする。

8. 作成したTCPヘッダーをIP担当部分に渡して、クライアントに送り返すよう依頼する。

9. パケットがクライアントに返り、IP担当部分を経由して、TCP担当部分に届く。

10. TCPヘッダーを調べて、サーバー側の接続動作が成功したかどうか確認する。

SYNが1なら接続成功なので、ソケットにIPアドレスやポート番号などを記録する。<br>
また、ソケットに「接続完了」を表す制御情報を記録する。

11. ACKビットを1にしたTCPヘッダーを送り返し、それがサーバーに届いたら接続動作のやり取りは終了。

サーバーと同じように(7)、パケットが届いたことをサーバーに知らせるため。

上記の流れでソケットはデータを送受信できる状態になる。<br>
(このとき、パイプのようなものでソケットがつながっていると考える。)<br>

このパイプのようなものを「コネクション」と呼び、データを送受信している間(closeと呼びだして切断するまでの間)ずっと存在している。<br>

コネクションが作成できたら、プロトコル・スタックの接続動作は終わりなので、アプリケーション(ブラウザ)に制御を戻す。

## データを送受信する

## プロトコル・スタックにHTTPリクエスト・メッセージを渡す

アプリ(ブラウザ)が「write」を呼びだして送信データ(HTTPリクエストメッセージ)をプロトコル・スタックに渡し、プロトコル・スタックが送信動作を実行する。<br>

動作のポイント<br>

* プロトコル・スタックは受け取った送信データの中身に何が書いてあるのかは関知せず、送信データの長さの分※だけバイナリ・データが1バイトずつ順番に並んでいると認識するだけ。<br>
※writeを呼びだす時に送信データの長さを指定している

* プロトコル・スタックは受け取ったデータを、すぐに送信するのではなく、とりあえず自分の内部にある送信用バッファ・メモリーにためてアプリが次のデータを渡してくるのを待つ

理由は、送信依頼する時にアプリからプロトコル・スタックに渡すデータの長さはアプリの種類や作り方によって決まり、データを全部一度に送信依頼する場合もあれば、1バイトずつ、あるいは一行分ずつ、細切れにして送信依頼することもある。<br>
何にしてもデータの長さはアプリの事情によって決まりプロトコル・スタックからコントロールすることはできない。<br>
その為、受け取ったデータをすぐに送るという単純な方法だと小さなパケットをたくさん送ってしまう可能性があり、ネットワークの利用効率が低下するのである程度データをためてから送信動作を行う。<br>

どの程度データをためてから送信動作を行うかはOSの種類やバージョンによって異なるが、下記の要素を基に判断する<br>

1. 1つのパケットに格納できるデータのサイズ
プロトコル・スタックは「MTU」というパラメータを基に判断する

MTU... 1つのパケットで運ぶことのできるデジタル・データの最大長のことで、イーサネットでは通常、1500バイトになる。<br>
       この「MTU」にはパケットの先頭部分にヘッダーが含まれているので、そこからヘッダーを除いたものが1つのパケットで運べるTCPデータの最大長になる。<br>
       その最大長の部分を「MSS」と呼び、アプリから受け取ったデータが「MSS」を超えるか、あるいは「MSS」に近い長さに達するまでデータをためておいて送信動作を行えばパケットが細切れになることはない。

2. タイミング
アプリの送信ペースが遅い場合は、MSSに近づくまでデータをためると、そこで時間がかかり送信動作が後れてしまう。<br>
なので、バッファにデータがたまらなくても適当な時間で送信動作を行うべき。<br>
そのため、プロトコル・スタックは内部にタイマーを持ち、それで一定時間以上経過したらパケットを送信するようにする。


この2つの判断要素の兼ね合いを適当に見計らって送信動作を実行する。<br>
(データのサイズを重視すれば送信に時間がかかり、タイミングを重視するとネットワークの利用効率が低下するため)<br>

しかし、TCPプロトコルの仕様にはその兼ね合いに関するルールはなく、実際にどう判断するかはプロトコル・スタックを作る開発者に任されている。<br>
そのため、OSの種類やバージョンによってその辺の動作は異なる。<br>

このように、プロトコル・スタックに一任する方法だと不都合が起こることもあるので、アプリ側で送信タイミングをコントロールする余地も残されている。<br>
データを送信する時にオプションを指定することができ、「バッファにためずにすぐに送信する」を指定すれば、プロトコル・スタックはバッファにためずにすぐに送信動作を実行することができる。(ブラウザとサーバーのやり取りなどにはこのオプションを使うことが多い)

### データが大きい時は分割して送る

HTTPリクエスト・メッセージは普通、それほど長くないので、1つのパケットに収まるが、フォームを使って長いデータを送る場合(ブログや掲示板などの長い文章)は1つのパケットに収まらないほど長くなることもある。(MSSの長さを超える)<br>
その場合は、送信バッファに入っているデータを先頭から順にMSSのサイズに合わせて分割し、分割した断片を1つずつパケットに入れて送信する。<br>
このように送信バッファにたまったデータの断片を送信すべき状況になったら、その先頭部分にTCPヘッダーを付加する。<br>
そこにソケットに記録されている制御情報を基にして、送信ポート番号や宛先ポート番号などの必要な項目を記載して、IP担当部分に渡して送信動作を実行してもらう。

### パケットが届いたことをACK番号を使って確認

TCPには、送信したパケットが相手に正しく届いたかどうか確認し、もし届いていなければ送りなおす機能がある。<br>

パケット送信後の確認方法<br>

TCP担当部分はデータを断片に分割するときに、その断片が先頭から数えて何バイト目に相当するか数えておく。<br>
そして、データの断片を送信するときに、数えておいた値をTCPヘッダーに記載する→その値が「シーケンス番号」という。※<br>
送るデータのサイズも受信側に伝える。(ヘッダーに記載して受信側に知らせるのではなく、受信側がパケット全体からヘッダーの長さを差し引いて計算してサイズを割り出す)<br>
上記の2つで送信したデータが何バイト目から始まる何バイト分なのかが分かり、受信側でパケットが抜けがないかどうか確認できる。
例:1460バイト目まで受信し終わった状態でシーケンス番号が1461のパケットが届けば、抜けがないことがわかり、2921のパケットが届けば抜けてしまったとわかる。

※実際はシーケンス番号の初期値は乱数を基に算出した初期値で始める。<br>
  接続動作の際にSYNというコントール・ビットを1にしてサーバーに送るときに、シーケンス番号に上記の初期値をセットする<br>

受信確認後の応答<br>

データの抜けがないことを確認したら、受信側はそれ以前に受信したデータと合わせてデータを何バイト目まで受信したのかを計算し、その値に1を足してTCPヘッダーの「ACK番号
」に記載して送信側に知らせる。<br>
この「ACK番号」を返す動作を受信確認応答と呼び、送信側はこれで相手がどこまで受信したのかを把握する。<br>
(ACK番号を記載した時は、コントロールビットのACKを1にする)<br>

この作業がクライアント側、サーバー側の両方向で行われる。<br>

TCPでは、上記の方法で相手がデータを受け取ったことを確認をし、その確認がとれるまでは送信したパケットを送信用のバッファ・メモリー領域内に保管しておく。<br>
もし、送信したデータに対応するACK番号が相手から返ってこなかったら、パケットを送り直す。

この仕組みは強力でネットワークのどこでエラーが起こったとしても、それを全部検出して回復処置(パケットを送り直すこと)ができる。<br>
この仕組みがあるので、他のところ(LANアダプタ、ハブ、ルーター)も回復処置をとらない。<br>
ただし、ケーブルが切れたり、サーバーがダウンするなどの理由はTCPがいくらデータを送りなおしてもデータが届かないので、TCPは回復の見込みがないものとみなして、データの送信動作を強制敵に終了し、アプリにエラーを通知する。

### ACK番号の待ち時間を調整

ACK番号が返るのを待つ時間を「タイムアウト値」と呼ぶ。<br>
ネットワークが混雑して、渋滞が起こるとACK番号が返ってくるのが遅れるので、それを見越して待ち時間をある程度長く設定しないといけない。<br>
そうしないと、ACK番号が返ってくる前にデータの送り直しを行ってしまう。<br>
→単に無駄なだけでなく、ネットワークに無駄なパケットを送ってしまい、余計にネットワークを混雑させてしまう。<br>
逆に、待ち時間を長すぎると、パケットの送りなおす動作が遅れてしまい速度低下の原因となってしまう。<br>

待ち時間は、短か過ぎず、かつ、長過ぎない適切な値に設定しないといけないので、TCPは待ち時間を動的に変更する方法をとる。<br>
→ACK番号が返ってくる時間を基準にして待ち時間を判断する。<br>
具体的には、データの送信動作を行っているときに常にACK番号が返ってくる時間を計測しておく。<br>
ACK番号が返ってくるのが遅くなったら、待ち時間を長くして、逆にすぐに返ってくるようなら待ち時間を短く設定する。

### ウィンドウ制御方法でACK番号を効率よく管理

パケットを1つ送ってそのACK番号を待つという方法は単純で分かりやすいが、ACK番号が返ってくるまでの間、何もせずに待つのは時間の無駄になってしまう。<br>
この無駄を省くために、TCPは「ウィンドウ制御」という方式で、データの送信とACK番号の動作を実行する。<br>

ウィンドウ制御... パケットを1つ送った後、ACK番号を待たずに、次々と連続して複数のパケットを送る方法。<br>
                  受信用のバッファ・メモリー(受信データの仮置き用)にデータが溢れないように、受信側から送信側に受信可能なデータ量を通知し※<br>
                  送信側はその量をを超えないようにして送信動作を実行する。<br>

                  ※TCPヘッダーのウィンドウ・フィールドで、送信側に知らせる。<br>

ウィンドウ制御もクライアント側とサーバー側の両方で行われる。<br>
受信可能なデータの最大値を「ウィンドウ・サイズ」と呼ぶ。(通常、受信側のバッファ・メモリーのサイズと同じサイズになる)

### ACK番号とウィンドウを相乗り

送受信動作の効率を上げるために、ACK番号とウィンドウを通知するタイミングを考慮する。

この2つはいつパケットを送るか<br>

* ウィンドウ
受信データが受信バッファにたまっていくだけなら、ウィンドウを逐一送信側に通知する必要はない。<br>
→ウィンドウの値はデータ送信の際に、送信するデータの量だけ引き算することで、送信側が自分で算出できる。<br>

 ウィンドウの通知が必要なのは、受信側で受信バッファからデータを取り出してアプリにデータを渡し、受信バッファの空き容量が増えたとき。 

* ACK番号

受信データでデータを受け取った時に、その内容を知らべ正常受信を確認出来たところで、送信側に送る。(データを受信した後すぐ)

この2つを合わせるとデータのパケットを受信する都度、ACK番号通知とウィンドウ通知のパケットが1つずつ別々に送信側に送られることになり、<br>
パケット量が多くなり効率が低下する。

そのため、受信側はACK番号やウィンドウを通知する時に、すぐにパケットを送るのではなく、しばらく待つ。<br>
その待っている間に、次の受信動作があれば両方を相乗りさせ、1つのパケットにまとめて送る。<br>
例:ACK番号の送信を見合わせている時に、ウィンドウ通知が起こったらACK番号とウィンドウを1つのパケットに相乗りさせて通知する<br>
   
ACK番号やウィンドウ通知が連続した場合は、最後のものだけを通知して途中のものは省略することができる。

### HTTPレスポンス・メッセージを受信

ブラウザがHTTPリクエスト・メッセージを送ったら次はWebサーバーからレスポンス・メッセージが返ってくるのを待ち、返ってきたらそれを受信する。<br>

受信の流れ<br>
1. サーバーから返ってくるレスポンス・メッセージを受け取る為に「read」プログラムを呼びだして、プロトコル・スタックに制御が移る。

2. 受信バッファから受信データを取り出してアプリに渡す。※

 受信したデータの断片とTCPヘッダーの内容を調べて途中でデータを抜けていないかどうかを検査する<br>
 問題がなければACK番号を送り返す。<br>
 データの断片を受信バッファに一時保管し、そこで断片をつなぎ合わせて元の姿にデータを復元してからアプリに渡す。(受信データをアプリが指定したメモリー領域に転記してから、アプリに制御を戻す)

3. アプリにデータを渡したら、タイミングを見計らってウィンドウを送信側に通知する。


※リクエスト・メッセージを送信して間もない時点だと、まだレスポンス・メッセージは返ってきていないので、一時作業を休止して、サーバーからレスポンス・メッセージのパケットが届いた時に、それを受信してアプリに渡す作業を再開する。

## サーバーから切断してソケットを抹消

### データを送り終わった時に切断

データの送受信を終了するのは、アプリが送信すべきデータを全部送り終わったと判断した時で、送り終わった側が切断フェーズに入る。<br>

(どこでデータ送受信動作が終わるかはアプリによって異なる。例: Webの場合はブラウザがリクエストして、サーバーがレスポンスを送り返し終わった所でサーバー側が切断フェーズに入る)<br>

プロトコル・スタックはクライアント側、サーバー側どちらから先に切断フェーズに入ってもいいようになっている。<br>
(どちらにしても、データを送り終わった側から切断フェーズに入る)

サーバー側から切断フェーズに入る例

1. サーバー側のアプリがSocketライブラリの「close」を呼びだす。

2. サーバー側のプロトコル・スタックがTCPヘッダーを作成し、IP担当部分に依頼してクライアントに送信する

TCPヘッダーに切断を表す情報をセットする。<br>
具体的には、コントロール・ビットのFINビットに1をセットする。

TCPヘッダーの送信と同時にサーバー側のソケットに切断動作に入ったという情報を記録する

3. クライアント側にTCPヘッダーが届く

サーバーからFINに1をセットしたTCPヘッダーが届いたら、クライアント側のプロトコル・スタックは自分のソケットにサーバー側が切断動作に入ったことを記録する。<br>

4. ACK番号をサーバー側に送り返す

FINを1にしたパケットを受け取ったことを知らせるためにACK番号を送る

5. サーバーからのデータを全部受信し終わったことをクライアント側のアプリ(ブラウザ)に知らせる

ACK番号を送り返してしばらくしたら、クライアント側のアプリが「read」を呼びだしてデータを取りにくるが、データを渡すのではなく<br>
サーバーからのデータを全部受信し終わったことをクライアント側のアプリ(ブラウザ)に知らせる。

6. クライアント側のアプリ(ブラウザ)も「close」を呼びだしてデータ送受信を終わりにする

クライアント側のプロトコル・スタックはサーバー側と同じように、FINビットに1をセットしたTCPヘッダーを作り、IP担当部分に依頼してサーバーに送信してもらう。

7. サーバー側からACK番号が返ってきたら、サーバーとのやり取りは終了

### ソケットを抹消

サーバーとのやり取りが終われば、そのソケットを使ってサーバーとやり取りすることはなくなる(ソケットが不要になる)。<br>
しかし、そこですぐにソケットを抹消せずに、しばらく待ってからソケットを抹消する(いろいろなケースの誤動作を防ぐため)<br>

一番わかりやすいケース(クライアントから切断動作が始まるケース)<br>

1. クライアントがFIN送信
2. サーバーがACK番号送信
3. サーバーがFIN送信
4. クライアントがACK番号送信

上記の流れで、最後にクライアントが送信したACK番号が消えてしまった場合、サーバー側はもう一度FINを送るかもしれない。<br>
そのとき、クライアントのソケットが抹消されていたら、記録されていた制御情報(ソケットに割り当てられていたポート番号)も何番だったかわからなくなる。<br>
その時点で、別のアプリがソケットを作成したら、新しいソケットに同じポート番号が割り当てられてしまうかもしれない。<br>
そして、サーバーが新しいソケットにFINが届いて、そのソケットが切断動作に入ってしまう。<br>

このような誤動作を防ぐことが、すぐにソケットを抹消せずにしばらく待つ理由になる。<br>

この待ち時間はパケットの再送動作と関係し、通常、数分程度でソケットを抹消する。<br>

パケットが消えた時に再送する動作は、数分継続し、数分経過してもパケットが届かなれば、回復の見込みがないものと判断され再送動作は止まる。<br>
それまでの間は再送パケットがネットワーク上に存在する可能性があり、誤動作を引き起こす可能性が残るため。<br>
なので、再送動作が完全に終わる時間だけ待てばいい。

## IPとイーサネットのパケット送受信動作

### パケットの基本

パケットはヘッダーとデータの2つの部分から構成される。<br>
ヘッダーには宛先を表すアドレスなどの制御情報が入っており、その後ろにデータが続く(宅急便でいう伝票がヘッダーで荷物がデータ)<br>

パケットの送信において、送信元と宛先を明確に区別しないほうが都合がいいことがある。<br>
→送信元と宛先の機器をまとめて「エンドノード」と呼ぶ。

TCP/IPネットワークにおけるパケットの目的地までの運び方<br>

ルーターとハブのという2種類のパケット中継装置で役割分担しながら、パケットを運ぶ。<br>

大まかな役割分担<br>

1. IPが目的地を見定めて次のIPの中継装置を示し、

2. サブネット内にあるイーサネットがその中継装置までパケットを運ぶ


TCP/IPヘッダーのパケットには「MACヘッダー」(イーサネット用のヘッダー)「IPヘッダー」(IP用のヘッダー)という2つのヘッダーがつけられている。

具体的な流れ<br>

送信元でパケットの目的地となるアクセス先サーバーのIPアドレスをIPヘッダーの宛先に記載する<br>

これでパケットの目的地がはっきりするので、IPはこの宛先がどの方向にあるのかを調べ、その方向にある次のルーターを調べる<br>

調べたルーターにパケットを届けるようにイーサネットに依頼する<br>

依頼の際にルーターに割り当てられたイーサネットのアドレス(MACアドレス)を調べ、それをMACヘッダーに記載する<br>
(こうすることで、依頼を受けたイーサネットにどのルーターにパケットを届ければいいのか伝わる)<br>

こうしてパケットを送信すると、イーサネットの仕組み従って動くハブに届く<br>

ハブにはパケットの行先を判断するための表のようなものがあり、MACヘッダーの宛先情報と表を付け合わせて、パケットの行先を判断し、パケットが進んでいく<br>

パケットがルーターに届くと、ルーターにはIP用の表があるので、IPヘッダーの宛先情報と付け合わせることで、次にどのルーターにパケットを中継すればいいのか判明する<br>

次のルーターにパケットを届けるために、そのルーターのMACアドレスを調べてそれをMACヘッダーを記載して(書き換える)パケットを次に向けて送信する。<br>

そしてハブを経由して、次のルーターにパケットが届く。これを繰り返せばパケットは目的地に届く<br>

目的地にパケットが届いたら、そこでパケットを受信し、届ける動作は完了する<br>

IPとイーサネットで役割分担することで、適材適所で通信技術を使い分けることができる。<br>
(イーサネットの部分は無線LANなどの他の技術が代わりに使えるため)

### パケット送受信動作の概要

全体の概要<br>
1. TCP担当部分がIP担当部分にパケット送信を依頼する

依頼動作の時、TCP担当部分はデータの断片にTCPヘッダーを付加したものをIP担当部分に渡す<br>
(これがパケットに入れる内容物になる)<br>
同時に送信相手のIPアドレスを示す

2. 依頼を受けたIP担当部分は内容物を一塊のデジタル・データとみなして、その前に制御情報を記載したヘッダーを付加する

付加するのはIPヘッダーとMACヘッダー。<br>

IPヘッダー... IPヘッダーの方は、IPプロトコルで規定されたルールに従ってIPアドレスで示された目的地までパケットを届ける際に使う制御情報を記載するもの<br>
              (IP用のヘッダー。IPアドレスを書く)<br>

MACヘッダー... イーサネットなどのLANを使って、最寄りのルーターまでパケットを運ぶ際に使う制御情報を記載したもの<br>
               (イーサネット用のヘッダー。MACアドレスを書く)<br>

3. 出来上がったパケットをネットワーク用のハードウェア(LANアダプタ※)に渡す

イーサネットや無線LANなどのハードウェアのこと。<br>

LANアダプタに渡した時のパケットの姿は0や1のビットが連なったデジタルデータで、それがLANアダプタによって電気や光の信号の格好に姿を変え、ケーブルに送り出される<br>
そして、信号はハブやルーターなどの中継装置に届き、中継装置が相手までパケットを届けてくれる

4. 相手にパケットが届いたらそこから返事(パケット)が返ってくるので、それを変換してIP担当部分に渡す

返ってくる返事(パケット)も中継装置が運び、送信元まで届けてくれ、今度はそのパケットを受信する。<br>
受信動作は送信動作の逆になり、ケーブルから信号の姿をしたパケットが入ってきたら、それをLANアダプタでデジタルデータの姿に戻す。<br>
そしてデジタルデータのパケットをIP担当部分に渡す

5. IP担当部分が受け取ったパケットのTCPヘッダーとデータの断片をTCP担当部分に渡す

6. 以降は依頼に合わせたTCP担当部分の動作


TCP担当部分のデータ送受信動作にはいくつかフェーズがあり、各フェーズで色々なパケットがあるが、<br>
IPパケット送受信動作はそのパケットの役割によらず、全て同じ。<br>
→IP担当部分はTCPヘッダーとデータ断片を一塊のバイナリ・データとみなしてその中身を見ずに送受信動作を実行するため<br>
(データの断片の有無、順番、TCPの動作フェーズなども一切気にせず、依頼された内容物をパケットの格好にして、相手に向けて送信する、あるいは届いたパケットを受信するだけ)

### 宛先IPアドレスを記載したIPヘッダーを作る

IP担当部分はTCP担当部分からパケット送受信の依頼を受けたら、IPヘッダーを作成し、TCPのヘッダーの前にくっつける。<br>

IPヘッダーには様々な項目が並んでおり、重要なのは「宛先IPアドレス」、「送信元IPアドレス」。<br>

「宛先IPアドレス」はTCP担当部分から通知されたもので、通信相手のIPアドレスをセットする。<br>
(このIPアドレスは元々はTCPの接続動作の際に、アプリ(ブラウザ)から通知されたもの)<br>

IPは自分で宛先を判断するのではなく、アプリが指定した相手に向けてパケットを送信するだけなので、もしアプリが誤ったIPアドレスを指定しても<br>
そのままIPヘッダーにセットする。それで正しく動かなくてもその責任はアプリにあるものとみなす。<br>

「送信元IPアドレス」はそのコンピュータの送信元となるLANアダプタに割り当てられたIPアドレスになる。<br>
(LANアダプタが複数ある場合は、1つのコンピュータにIPアドレスが複数あることになり、どのLANアダプタから送信するか判断してセットする)

パケットを渡す相手を判断する方法は、ルーターがIP用の表を使って次のルーターを決める動作と同じ。<br>

IP用の表を「経路表」と呼ぶ。<br>

経路表の内容(Windowsコマンド route print)<br>

「NetworkDestination」(表の一番左)... 宛先のIPアドレス<br>

「Interface」(表の右から2番目)... LANアダプタなどのネットワーク用インターフェースを表す(送信元IPアドレス このインターフェースからパケットを送信すれば、相手にパケットを届けることができる)<br>

「Gateway」(表の右から3番目)...次のルーターのIPアドレスを表し、そのIPアドレスを持つルーターにパケットを渡せばそのルーターが目的地にパケットを中継してくれることを表す。<br>

「NetworkDestination」と「Netmask」が0.0.0.0 ... 「デフォルト・ゲートウェイ」を表しほかに該当するものがない場合に、この行が該当するものとみなす。<br>

上記の経路表の内容でどのLANアダプタからパケットを送信すべきかわかるので、そのLANアダプタに割り当てられているIPアドレスをIPヘッダーの送信元IPアドレスにセットする<br>

IPヘッダーの「プロトコル番号」にパケットに入れた内容物がどこから依頼されたものかを表す値をセットする<br>

例:TCPから依頼されたもの→「06」(16進数表記) UDPから依頼されたもの「17」(16進数表記) という具合に値はルールで決められている。

### イーサネット用のMACヘッダーを作成する

IPヘッダーをつけたら、IP担当部分はその前にMACヘッダーをつける。<br>

イーサネットはTCP/IPとは違う仕組みでパケットの宛先を判断するため、その宛先判断の仕組みで「MACヘッダー」を使う<br>

MACヘッダーの項目<br>

「宛先MACアドレス」... パケットを届ける相手のMACアドレス。LANでのパケット配送はこのアドレスに基づいて行われる<br>

「送信元MACアドレス」... このパケットを送信した側のMACアドレス。パケットを受け取ったとき、この値によって誰が送ったのかを判断する<br>

「イーサ・タイプ」 ... 使用するプロトコルの種類を表す。通常のTCP/IPの通信で使うのは、「0800」(IPプロトコル)と「0806」(ARPプロトコル)の２つ<br>
                       (MACヘッダーに続く、パケットの内容物が何なのかをイーサタイプで表す。)

IPアドレスが32ビットなのに対して、MACアドレスは48ビットあり、IPアドレスが「何丁目何番地」のように、グループ化のような考え方があるが、<br>
MACアドレスにはそのような考え方はなく、48ビットを1つの値と考える。<br>

MACヘッダーの作成(3つの項目に値をセットする)<br>

1. イーサ・タイプにIPプロトコルを表す「0800」という値をセットする

2. 送信元MACアドレスに自分のLANアダプタのMACアドレスをセットする

MACアドレスは、LANアダプタを製造する時に、ROMに書き込まれている。<br>

LANアダプタが複数ある場合は、どのLANアダプタから送信するのかを判断して(IPの経路表)そのLANアダプタに割り当てられたMACアドレスをセットする

3. 宛先MACアドレスにパケットを渡す相手のMACアドレスをセットする

最初の時点では、パケットを渡す相手が誰なのかわかっていないので、まずパケットを渡す相手が誰なのかを経路表で調べる<br>
(経路表の「Gateway」で調べる)<br>

パケットを渡す相手が分かれば、その相手のMACアドレスを調べる必要がある。<br>
(IPアドレスからMACアドレスを調べる)

調べ方は下記(ARPで宛先ルーターのMACアドレスを調べる)

### ARPで宛先ルーターのMACアドレスを調べる

「ARP」... イーサネットのブロードキャスト(つながっている全員にパケットを届ける)の仕組みを利用して、IPアドレスからMACアドレスを調べる。※<br>

※「○○というIPアドレスを持っている人はいませんか。いたらMACアドレスを教えてください」と全員に問いかける。すると該当者から<br>
  「それは私です。私のMACアドレスはｘｘｘｘです。」というように応答が返ってくるという具合。(相手が自分と同じサブネット内に存在すれば、MACアドレスがわかる)<br>

上記の方法で調べたMACアドレスをMACヘッダーにセットすれば、MACヘッダーはできあがる。<br>

しかし、パケットを送る都度これをやるとARPのパケットが増えてしまう。<br>
→一度調べた結果を「ARPキャッシュ」というメモリー領域に保存して再利用する<br>

最初にARPキャッシュを調べ、そこに相手のMACアドレスが保存されていたら、ARPの問い合わせを送らずにARPキャッシュに保存されている値を使い、<br>
ARPキャッシュに保存されていない場合だけARPの問い合わせを行う。<br>
(ARPキャッシュの内容 Windowsコマンド arp -a)<br>

ARPキャッシュを使うことで、ARPのパケットを減らすことができるが、いつまでもARPキャッシュに保存したMACアドレスを使い続けると問題が起こる。<br>
(IPアドレスを設定し直した場合に、ARPキャッシュの内容と現実に食い違いが起こるなど)<br>

それを防ぐために、ARPキャッシュに保存した値は時間が経つと削除するようになっている<br>
(OSの種類によって異なるが、通常は数分程度)<br>

作成したMACヘッダーをIPヘッダーの前につけたらパケットは完成するので、それをLANアダプタに渡す。<br>

### イーサネットの基本

イーサネットは多数のコンピュータが色々な相手と自由に安価に通信するために考案された通信技術で、ネットワークの実体はケーブルがあるだけ。

イーサネットは3つの性質を持つ(無線LANにも当てはまる)<br>
* MACヘッダーの宛先MACアドレスに記載された相手にパケットが届く。
(スイッチング・ハブが宛先MACアドレスで目的地を見定めてパケットを送る)
* MACヘッダーの送信元MACアドレスで送信元を表す。
* イーサ・タイプでパケットの内容物を表す。

イーサネットに接続された機器(クライアントパソコン、サーバー、ルーター)の動作は全て共通している。<br>
イーサネットはIPと同様に、パケットの内容を確認しないため、イーサネットの送受信動作はTCPの動作フェーズにかかわらず、すべてに共通する。<br>
(アプリの種類も影響しない)

### IPパケットを電気や光の信号に変換して送信

LANアダプタ ... IPが作成したデジタルデータ(パケット)を電気や光の信号に変換して、ネットワークのケーブルに送り出す<br>

LANドライバ ... LANアダプタをコントールするもの(LANアダプタの構造はメーカーによって異なるので、ドライバもLANアダプタのメーカーが用意した専用のものを使う)<br>

<LANアダプタの初期化><br>

LANアダプタは電源を入れてOSを起動する時に、LANドライバによって、初期化作業を行い、その後、使用可能になる<br>

イーサネット特有の作業として、イーサネットの送受信動作をコントロールする「MAC」という回路にMACアドレスをセットするというものがある<br>
(LANアダプタのROMには、全世界で重複しないように一元管理されたMACアドレスが製造時に書き込まれており、それを読みだしてMAC回路にセットする)

### さらにパケットに3つの制御用データを付ける

1. LANドライバはIP担当部分からパケットを受け取る(LANドライバ)

2. 受け取ったパケットをLANアダプタ内のバッファ・メモリーにコピーする(LANドライバ)

3. そのパケットを送信するようにMAC回路にコマンドを送る(LANドライバ)

4. 送信パケットをバッファ・メモリーから取り出し、3つのデータを付け加える(MAC回路)

先頭に「プリアンブル」と「スタート・フレーム・デリミタ」という2つのデータを付け加え、末尾に「フレーム・チェック・シーケンス(FCS)」というエラー検出用のデータを付け加える<br>

* プリアンブル

送信するパケットを読み取るときのタイミングをとるためのもので、「10101010...」というように1と0が交互に現れるビット列が56ビット分続くもの<br>

デジタル・データを電気信号で表すときは、0と1のビット値を電圧や電流の値に対応付ける<br>

1や0が続くと信号の変化がなくなってしまい、ビットの区切りが判別できなくなる<br>
→「クロック」というビットの区切りを表す信号を送る方法がある<br>

ケーブルが長くなるとデータ信号とクロックが伝わる時間に差ができてしまい、クロックがずれてしまう。<br>
→データ信号とクロックを合成して、1つの信号にして解決する<br>

* スタート・フレーム・デリミタ

プリアンブルに続いており、最後のビットパターンが11になっており、これで波形が変わる<br>
受信側はこれを目印にして信号からデータを抽出し始める<br>
→スタート・フレーム・デリミタがパケットの始まりを示す目印となっている

* フレーム・チェック・シーケンス(FCS)

パケットを運ぶ途中、雑音などの影響で波形が乱れデータが化けてしまった場合に、それを検出するために使う<br>
32ビットのビット列で、パケットの先頭部分から最後尾までの内容をある計算式に基づいて計算したもの。<br>
パケットのデータが化けるようなことがあると、受信側で計算したFCSが送信時に計算したものと違うものになるため、その食い違いで、データが化けてしまったことを検出する

### ハブに向けてパケットを送信

MAC回路で3つの制御情報を付け加えたら、ケーブルに送り出すパケットは完成する<br>

信号と送信する動作にはリピーター・ハブを使った「半2重モード」とスイッチング・ハブを使った「全2重モード」がある※<br>

※送信動作と受信動作を同時に並行して実行できるものを「前2重」といい、どちらか一方しかできないものを「半2重」という。<br>

半2重モードの動作<br>

1. ケーブルに他に機器が送信した信号が流れているかを調べる

信号が流れていたら、それが終わるまで待つ(信号が流れているときに送信動作を始めると、信号が衝突するため)

2. 信号がなければ、送信動作を始める

MAC回路がプリアンブルの頭から順番に1ビットずつデジタル・データを電気信号に変換し、それを「PHY」もしくは「MAU」と呼ぶ、信号送受信部分に送ります。<br>

3. PHY(MAU)回路が受け取った信号をケーブルに送りだす形式に変換して、ケーブルに送信する

ケーブルに送信する際に、受信信号線から信号が流れ込んでこないかどうかも監視する<br>
(送信前に信号が流れていないことを確認してから送信動作に入ったので、基本的には、受信信号線に信号は流れてこない)<br>

まれに、同時に複数の機器が送信動作に入り、受信信号線に信号が流れてくることがある<br>
→互いの信号が交じり合ってしまい、見分けがつかない状態になる。(これを「衝突」という)<br>

衝突するとそれ以上送信動作を続けても意味はないので、送信動作を中止し、衝突が起こったことを他に機器に知らせるために「ジャミング信号」という特殊な信号をしばらくの間流し、その後送信動作を止める<br>

送信動作の待ち時間は、MACアドレスを基に乱数を生成し、そこから待ち時間を計算する<br>

イーサネットが混雑してくると、衝突の可能性が高くなるので、送り直したときに別の機器と送信動作が重なり、再び衝突することもある<br>
その場合は、待ち時間を2倍に増やして、再度送る<br>

衝突が起こるたびに、2倍ずつ待ち時間を増やして、10回までやり直して、それでもだめなときは送信エラーにする<br>

全2重モード<br>

送信と受信を同時に実行できるので衝突は起こらない。<br>

受信信号から信号が流れてきても、お構いなしに、単純に信号を送るだけ。

### 返ってきたパケットを受け取る

半2重動作のイーサネットでは、1台が送信した信号が、リピーターハブに接続したケーブル全部に流れていく。<br>
→自分宛のものに限らず、誰かが信号を送ると、それが全部、受信信号線から流れてくるので、その信号を全部取り込むことから始まる<br>

1. プリアンブル、スタート・フレーム・デリミタでタイミング、変換の開始始点を確認して、デジタルデータに変換する

送信とは逆で、PHY(MAU)回路で信号を共通形式に変換して、MAC回路に送り、MAC回路で信号をデジタルデータに変換し、バッファ・メモリーにためていく<br>

2. FCSを検査する

信号の最後まで達したら、末尾のFCSと計算したFCSを検査し、食い違いがあればエラー・パケットと見なして棄てる。

3. MACヘッダーの宛先MACアドレスとMACにセットした自分のMACアドレスを見比べて、自分宛のものかどうかを判断する

宛先MACアドレスが自分宛の場合のみ、パケットを取り込んでバッファ・メモリーに保存する<br>
(他人宛のパケットは受信する必要がないので、棄てる)

4. パケットを受信したことをコンピュータ本体(LANドライバ)に通知する

通知は「割り込み」という仕組みを使う<br>

割り込み ... コンピュータが実行している仕事に割り込んで、LANアダプタのほうに注意を向けさせること※<br>
             LANアダプタが拡張バス・スロット部分にある割り込み用の信号線に信号を送ると、CPUはその時実行していた仕事を一時的に棚上げして、割り込み処理用のプログラムに切り替える<br>
             そこから、LANドライバが呼びだされて、LANアダプタをコントロールして送受信動作を行う。
             
※コンピュータ本体(LANドライバも)LANアダプタの動きを監視しているわけではなく、他の仕事を実行しているため<br>

5. 割り込みによって、LANドライバが動き、LANアダプタのバッファ・メモリーから受信したパケットを取り出す

6. LANドライバがMAヘッダーのタイプ・フィールドの値からプロトコルを判別し、パケットを渡す

ほとんど、TCP/IPのプロトコル・スタックにパケットを渡す(タイプの値「0800」)

### サーバーからの応答パケットをIPからTCPに渡す

1. サーバーから送り返されたパケットのタイプに応じて、LANドライバがプロトコル・スタックにパケットを渡す<br>
(TCP/IPのプロトコル・スタックにパケットを渡す(タイプの値「0800」))<br>

2. IP担当部分がIPヘッダー部分を調べ、フォーマットに誤りが無いか調べる

3. 問題がなければ、宛先IPアドレスを調べて、受信したLANアダプタのIPアドレスと一致したら、パケットを受信する

もし、宛先IPアドレスが自分と異なれば、何かの誤りになりエラーになる。<br>
エラーが起こった場合は、IP担当部分が「ICMP」というメッセージを使って、通信相手にエラーを通知する<br>

パケットの受信とは別の仕事で、IPプロトコルには「フラグメンテーション」という機能がある

フラグメンテーション ... パケットを運ぶ途中にある通信回線やLANには短いパケットしか扱えないものがあり、パケットを短くするために、1つのパケットを複数に分割すること

もし、受信したパケットが分割されたものなら、IP担当部分はそれを元にパケットに戻す。<br>
(分割されたパケットは、IPヘッダーにある「フラグ」という項目を見ればわかるので、IP担当部分のメモリーに一時的に保管する。<br>
IPヘッダーにあるID情報に同じ値を持つパケットが到着するのを待つ。(分割されたパケットはID情報が同じになる)<br>
また、「フラグメント・オフセット」という項目にはそのパケットが元のパケットのどの位置にあったものかを表す情報が入っている。<br>
分割されたパケットが全部到着するのを待って、パケットを元に戻す→「リアセンブリング」と呼ぶ)

4. IP担当部分の役割が終われば、パケットをTCP担当部分に渡す

TCP担当部分がIPヘッダーに記載された宛先、送信元IPアドレス、TCPヘッダーに記載された宛先ポート番号、送信元ポート番号を調べ、該当するソケットを探す

5. 該当するソケットを探し出したら、通信の進行状態を確認し適切な動作を実行する

例:アプリのデータを入れたパケットであれば、受信確認のパケットを送り返して、データを受信バッファにためてアプリがデータを取りに来るのを待つ<br>
   接続や切断フェーズの制御用パケットであれば、応答の制御用パケットを送り返したり、接続や切断動作の状況をアプリに通知する

### UDPプロトコルを用いた送受信動作










